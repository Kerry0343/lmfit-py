<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Performing Fits and Analyzing Outputs &#8212; Non-Linear Least-Squares Minimization and Curve-Fitting for Python</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx13.css?v=aac77d10" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css?v=572af1d6" />
    <link rel="stylesheet" type="text/css" href="_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <script src="_static/documentation_options.js?v=28d163b9"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modeling Data and Curve Fitting" href="model.html" />
    <link rel="prev" title="Parameter and Parameters" href="parameters.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script>
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="contents.html">Contents</a></li>
    <li><a href="examples/index.html">Examples</a></li>
    <li><a href="installation.html">Installation</a></li>
    <li><a href="faq.html">FAQ</a></li>
    <li><a href="support.html">Support</a></li>
    <li><a href="https://github.com/lmfit/lmfit-py">Develop</a></li>
  </ul>
  <div>
    <a href="index.html">
      <img src="_static/lmfitheader.png" alt="LMFIT" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="model.html" title="Modeling Data and Curve Fitting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="parameters.html" title="Parameter and Parameters"
             accesskey="P">previous</a> |</li>
    <li>[ <a href="intro.html">intro</a> |</li>
    <li><a href="parameters.html">parameters</a> |</li>
    <li><a href="#">minimize</a> |</li>
    <li><a href="model.html">model</a> |</li>
    <li><a href="builtin_models.html">built-in models</a> |</li>
    <li><a href="confidence.html">confidence intervals</a> |</li>
    <li><a href="bounds.html">bounds</a> |</li>
    <li><a href="constraints.html">constraints</a> ]</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Performing Fits and Analyzing Outputs</a><ul>
<li><a class="reference internal" href="#the-minimize-function">The <code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code> function</a><ul>
<li><a class="reference internal" href="#lmfit.minimizer.minimize"><code class="docutils literal notranslate"><span class="pre">minimize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-fitting-function">Writing a Fitting Function</a></li>
<li><a class="reference internal" href="#types-of-data-to-use-for-fitting">Types of Data to Use for Fitting</a></li>
<li><a class="reference internal" href="#choosing-different-fitting-methods">Choosing Different Fitting Methods</a></li>
<li><a class="reference internal" href="#minimizerresult-the-optimization-result"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code> – the optimization result</a><ul>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult"><code class="docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a><ul>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.residual"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.residual</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.params"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.params</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.uvars"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.uvars</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.var_names"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.var_names</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.covar"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.covar</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.init_vals"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.init_vals</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.init_values"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.init_values</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.aborted"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.aborted</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.status"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.status</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.success"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.success</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.errorbars"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.errorbars</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.message"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.message</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.ier"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.ier</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.lmdif_message"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.lmdif_message</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.call_kws"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.call_kws</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.flatchain"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.flatchain</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.nfev"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.nfev</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.nvarys"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.nvarys</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.ndata"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.ndata</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.nfree"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.nfree</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.chisqr"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.chisqr</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.redchi"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.redchi</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.aic"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.aic</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.bic"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.bic</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.MinimizerResult.show_candidates"><code class="docutils literal notranslate"><span class="pre">MinimizerResult.show_candidates()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#goodness-of-fit-statistics">Goodness-of-Fit Statistics</a></li>
<li><a class="reference internal" href="#akaike-and-bayesian-information-criteria">Akaike and Bayesian Information Criteria</a></li>
<li><a class="reference internal" href="#uncertainties-in-variable-parameters-and-their-correlations">Uncertainties in Variable Parameters, and their Correlations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#getting-and-printing-fit-reports">Getting and Printing Fit Reports</a><ul>
<li><a class="reference internal" href="#lmfit.printfuncs.fit_report"><code class="docutils literal notranslate"><span class="pre">fit_report()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-iteration-callback-function">Using a Iteration Callback Function</a></li>
<li><a class="reference internal" href="#using-the-minimizer-class">Using the <code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code> class</a><ul>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer"><code class="docutils literal notranslate"><span class="pre">Minimizer</span></code></a><ul>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.minimize"><code class="docutils literal notranslate"><span class="pre">Minimizer.minimize()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.leastsq"><code class="docutils literal notranslate"><span class="pre">Minimizer.leastsq()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.least_squares"><code class="docutils literal notranslate"><span class="pre">Minimizer.least_squares()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.scalar_minimize"><code class="docutils literal notranslate"><span class="pre">Minimizer.scalar_minimize()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.prepare_fit"><code class="docutils literal notranslate"><span class="pre">Minimizer.prepare_fit()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.brute"><code class="docutils literal notranslate"><span class="pre">Minimizer.brute()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.basinhopping"><code class="docutils literal notranslate"><span class="pre">Minimizer.basinhopping()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.ampgo"><code class="docutils literal notranslate"><span class="pre">Minimizer.ampgo()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.shgo"><code class="docutils literal notranslate"><span class="pre">Minimizer.shgo()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.dual_annealing"><code class="docutils literal notranslate"><span class="pre">Minimizer.dual_annealing()</span></code></a></li>
<li><a class="reference internal" href="#lmfit.minimizer.Minimizer.emcee"><code class="docutils literal notranslate"><span class="pre">Minimizer.emcee()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#minimizer-emcee-calculating-the-posterior-probability-distribution-of-parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.emcee()</span></code> - calculating the posterior probability distribution of parameters</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="parameters.html"
                          title="previous chapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code></a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="model.html"
                          title="next chapter">Modeling Data and Curve Fitting</a></p>
  </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="performing-fits-and-analyzing-outputs">
<span id="module-lmfit.minimizer"></span><span id="minimize-chapter"></span><h1>Performing Fits and Analyzing Outputs<a class="headerlink" href="#performing-fits-and-analyzing-outputs" title="Link to this heading">¶</a></h1>
<p>As shown in the previous chapter, a simple fit can be performed with the
<a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> function. For more sophisticated modeling, the
<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> class can be used to gain a bit more control, especially
when using complicated constraints or comparing results from related fits.</p>
<section id="the-minimize-function">
<h2>The <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> function<a class="headerlink" href="#the-minimize-function" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> function is a wrapper around <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> for
running an optimization problem. It takes an objective function (the
function that calculates the array to be minimized), a <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code>
object, and several optional arguments. See <a class="reference internal" href="#fit-func-label"><span class="std std-ref">Writing a Fitting Function</span></a> for
details on writing the objective function.</p>
<dl class="py function">
<dt class="sig sig-object py" id="lmfit.minimizer.minimize">
<span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fcn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'leastsq'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_cb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_fcn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fit_kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.minimize" title="Link to this definition">¶</a></dt>
<dd><p>Perform the minimization of the objective function.</p>
<p>The minimize function takes an objective function to be minimized,
a dictionary (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code></a> ; Parameters) containing
the model parameters, and several optional arguments including the fitting
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcn</strong> (<em>callable</em>) – <p>Objective function to be minimized. When method is <cite>‘leastsq’</cite> or
‘<cite>least_squares</cite>’, the objective function should return an array
of residuals (difference between model and data) to be minimized
in a least-squares sense. With the scalar methods the objective
function can either return the residuals array or a single scalar
value. The function must have the signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fcn</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
</pre></div>
</div>
</p></li>
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a>) – Contains the Parameters for the model.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – <p>Name of the fitting method to use. Valid values are:</p>
<ul>
<li><p><cite>’leastsq’</cite>: Levenberg-Marquardt (default)</p></li>
<li><p><cite>’least_squares’</cite>: Least-Squares minimization, using Trust Region Reflective method</p></li>
<li><p><cite>’differential_evolution’</cite>: differential evolution</p></li>
<li><p><cite>’brute’</cite>: brute force method</p></li>
<li><p><cite>’basinhopping’</cite>: basinhopping</p></li>
<li><p><cite>’ampgo’</cite>: Adaptive Memory Programming for Global Optimization</p></li>
<li><p>’<cite>nelder</cite>’: Nelder-Mead</p></li>
<li><p><cite>’lbfgsb’</cite>: L-BFGS-B</p></li>
<li><p><cite>’powell’</cite>: Powell</p></li>
<li><p><cite>’cg’</cite>: Conjugate-Gradient</p></li>
<li><p><cite>’newton’</cite>: Newton-CG</p></li>
<li><p><cite>’cobyla’</cite>: Cobyla</p></li>
<li><p><cite>’bfgs’</cite>: BFGS</p></li>
<li><p><cite>’tnc’</cite>: Truncated Newton</p></li>
<li><p><cite>’trust-ncg’</cite>: Newton-CG trust-region</p></li>
<li><p><cite>’trust-exact’</cite>: nearly exact trust-region</p></li>
<li><p><cite>’trust-krylov’</cite>: Newton GLTR trust-region</p></li>
<li><p><cite>’trust-constr’</cite>: trust-region for constrained optimization</p></li>
<li><p><cite>’dogleg’</cite>: Dog-leg trust-region</p></li>
<li><p><cite>’slsqp’</cite>: Sequential Linear Squares Programming</p></li>
<li><p><cite>’emcee’</cite>: Maximum likelihood via Monte-Carlo Markov Chain</p></li>
<li><p><cite>’shgo’</cite>: Simplicial Homology Global Optimization</p></li>
<li><p><cite>’dual_annealing’</cite>: Dual Annealing optimization</p></li>
</ul>
<p>In most cases, these methods wrap and use the method of the same
name from <cite>scipy.optimize</cite>, or use <cite>scipy.optimize.minimize</cite> with
the same <cite>method</cite> argument. Thus <cite>‘leastsq’</cite> will use
<cite>scipy.optimize.leastsq</cite>, while <cite>‘powell’</cite> will use
<cite>scipy.optimize.minimizer(…, method=’powell’)</cite></p>
<p>For more details on the fitting methods please refer to the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.html">SciPy docs</a>.</p>
</p></li>
<li><p><strong>args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em>, </em><em>optional</em>) – Positional arguments to pass to <cite>fcn</cite>.</p></li>
<li><p><strong>kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Keyword arguments to pass to <cite>fcn</cite>.</p></li>
<li><p><strong>iter_cb</strong> (<em>callable</em><em>, </em><em>optional</em>) – <p>Function to be called at each fit iteration. This function should
have the signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iter_cb</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">),</span>
</pre></div>
</div>
<p>where <cite>params</cite> will have the current parameter values, <cite>iter</cite> the
iteration number, <cite>resid</cite> the current residual array, and <cite>*args</cite>
and <cite>**kws</cite> as passed to the objective function.</p>
</p></li>
<li><p><strong>scale_covar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to automatically scale the covariance matrix (default is
True).</p></li>
<li><p><strong>nan_policy</strong> (<em>{'raise'</em><em>, </em><em>'propagate'</em><em>, </em><em>'omit'}</em><em>, </em><em>optional</em>) – <p>Specifies action if <cite>fcn</cite> (or a Jacobian) returns NaN values. One
of:</p>
<ul>
<li><p><cite>’raise’</cite> : a <cite>ValueError</cite> is raised</p></li>
<li><p><cite>’propagate’</cite> : the values returned from <cite>userfcn</cite> are un-altered</p></li>
<li><p><cite>’omit’</cite> : non-finite values are filtered</p></li>
</ul>
</p></li>
<li><p><strong>reduce_fcn</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em> or </em><em>callable</em><em>, </em><em>optional</em>) – Function to convert a residual array to a scalar value for the
scalar minimizers. See Notes in <cite>Minimizer</cite>.</p></li>
<li><p><strong>calc_covar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to calculate the covariance matrix (default is True) for
solvers other than <cite>‘leastsq’</cite> and <cite>‘least_squares’</cite>. Requires the
<cite>numdifftools</cite> package to be installed.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations (default is None). The
default value depends on the fitting method.</p></li>
<li><p><strong>**fit_kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Options to pass to the minimizer being used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the optimized parameters and several
goodness-of-fit statistics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.0: </span>Return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>.</p>
</div>
<p class="rubric">Notes</p>
<p>The objective function should return the value to be minimized. For
the Levenberg-Marquardt algorithm from leastsq(), this returned value
must be an array, with a length greater than or equal to the number of
fitting variables in the model. For the other methods, the return
value can either be a scalar or an array. If an array is returned, the
sum-of- squares of the array will be sent to the underlying fitting
method, effectively doing a least-squares optimization of the return
values.</p>
<p>A common use for <cite>args</cite> and <cite>kws</cite> would be to pass in other data needed
to calculate the residual, including such things as the data array,
dependent variable, uncertainties in the data, and other data structures
for the model calculation.</p>
<p>On output, <cite>params</cite> will be unchanged. The best-fit values and, where
appropriate, estimated uncertainties and correlations, will all be
contained in the returned <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>. See
<a class="reference internal" href="#fit-results-label"><span class="std std-ref">MinimizerResult – the optimization result</span></a> for further details.</p>
<p>This function is simply a wrapper around <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> and is
equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">Minimizer</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fcn_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="n">kws</span><span class="p">,</span>
                   <span class="n">iter_cb</span><span class="o">=</span><span class="n">iter_cb</span><span class="p">,</span> <span class="n">scale_covar</span><span class="o">=</span><span class="n">scale_covar</span><span class="p">,</span>
                   <span class="n">nan_policy</span><span class="o">=</span><span class="n">nan_policy</span><span class="p">,</span> <span class="n">reduce_fcn</span><span class="o">=</span><span class="n">reduce_fcn</span><span class="p">,</span>
                   <span class="n">calc_covar</span><span class="o">=</span><span class="n">calc_covar</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kws</span><span class="p">)</span>
<span class="n">fitter</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="writing-a-fitting-function">
<span id="fit-func-label"></span><h2>Writing a Fitting Function<a class="headerlink" href="#writing-a-fitting-function" title="Link to this heading">¶</a></h2>
<p>An important component of a fit is writing a function to be minimized –
the <em>objective function</em>. Since this function will be called by other
routines, there are fairly stringent requirements for its call signature
and return value. In principle, your function can be any Python callable,
but it must look like this:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">func(params,</span> <span class="pre">*args,</span> <span class="pre">**kws):</span></span></dt>
<dd><p>Calculate objective residual to be minimized from parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code></a>) – Parameters.</p></li>
<li><p><strong>args</strong> – Positional arguments. Must match <code class="docutils literal notranslate"><span class="pre">args</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a>.</p></li>
<li><p><strong>kws</strong> – Keyword arguments. Must match <code class="docutils literal notranslate"><span class="pre">kws</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Residual array (generally <code class="docutils literal notranslate"><span class="pre">data-model</span></code>) to be minimized in the least-squares sense.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html">numpy.ndarray</a>. The length of this array cannot change between calls.</p>
</dd>
</dl>
</dd></dl>

<p>A common use for the positional and keyword arguments would be to pass in other
data needed to calculate the residual, including things as the data array,
dependent variable, uncertainties in the data, and other data structures for the
model calculation.</p>
<p>The objective function should return the value to be minimized. For the
Levenberg-Marquardt algorithm from <code class="xref py py-meth docutils literal notranslate"><span class="pre">leastsq()</span></code>, this returned value <strong>must</strong> be an
array, with a length greater than or equal to the number of fitting variables in the
model. For the other methods, the return value can either be a scalar or an array. If an
array is returned, the sum of squares of the array will be sent to the underlying fitting
method, effectively doing a least-squares optimization of the return values.</p>
<p>Since the function will be passed in a dictionary of <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code>, it is advisable
to unpack these to get numerical values at the top of the function. A
simple way to do this is with <code class="xref py py-meth docutils literal notranslate"><span class="pre">Parameters.valuesdict()</span></code>, as shown below:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>


<span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># unpack parameters: extract .value attribute for each parameter</span>
    <span class="n">parvals</span> <span class="o">=</span> <span class="n">pars</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">]</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span>
    <span class="n">decay</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;decay&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">period</span><span class="p">)</span><span class="o">*</span><span class="mf">1.e-10</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">parvals</span><span class="p">[</span><span class="s1">&#39;amp&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="n">period</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">decay</span><span class="o">*</span><span class="n">decay</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model</span>
    <span class="k">if</span> <span class="n">eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model</span> <span class="o">-</span> <span class="n">data</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">model</span><span class="o">-</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">eps</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">x</span></code> is a positional (required) argument, while the
<code class="docutils literal notranslate"><span class="pre">data</span></code> array is actually optional (so that the function returns the model
calculation if the data is neglected). Also note that the model
calculation will divide <code class="docutils literal notranslate"><span class="pre">x</span></code> by the value of the <code class="docutils literal notranslate"><span class="pre">period</span></code> Parameter. It
might be wise to ensure this parameter cannot be 0. It would be possible
to use bounds on the <code class="xref py py-class docutils literal notranslate"><span class="pre">Parameter</span></code> to do this:</p>
<div class="jupyter_cell docutils container">
<div class="cell_output docutils container">
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;period&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>but putting this directly in the function with:</p>
<div class="jupyter_cell docutils container">
<div class="cell_output docutils container">
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">period</span><span class="p">)</span><span class="o">*</span><span class="mf">1.e-10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>is also a reasonable approach. Similarly, one could place bounds on the
<code class="docutils literal notranslate"><span class="pre">decay</span></code> parameter to take values only between <code class="docutils literal notranslate"><span class="pre">-pi/2</span></code> and <code class="docutils literal notranslate"><span class="pre">pi/2</span></code>.</p>
</section>
<section id="types-of-data-to-use-for-fitting">
<span id="fit-data-label"></span><h2>Types of Data to Use for Fitting<a class="headerlink" href="#types-of-data-to-use-for-fitting" title="Link to this heading">¶</a></h2>
<p>Minimization methods assume that data is numerical.  For all the fitting
methods supported by lmfit, data and fitting parameters are also assumed to
be continuous variables.  As the routines make heavy use of numpy and scipy,
the most natural data to use in fitting is then numpy nd-arrays.  In fact, many
of the underlying fitting algorithms - including the default <code class="xref py py-meth docutils literal notranslate"><span class="pre">leastsq()</span></code>
method - <strong>require</strong> the values in the residual array used for the
minimization to be a 1-dimensional numpy array with data type (<cite>dtype</cite>) of
“float64”: a 64-bit representation of a floating point number (sometimes called
a “double precision float”).</p>
<p>Python is generally forgiving about data types, and in the scientific Python
community there is a concept of an object being “array like” which essentially
means that the can usually be coerced or interpreted as a numpy array, often
with that object having an <code class="docutils literal notranslate"><span class="pre">__array__()</span></code> method specially designed for that
conversion.  Important examples of objects that can be considered “array like”
include Lists and Tuples that contain only numbers, pandas Series, and HDF5
Datasets. Many objects from data-processing libraries like dask, xarray, zarr,
and more are also “array like”.</p>
<p>Lmfit tries to be accommodating in the data that can be used in the fitting
process. When using <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a>, the data you pass in as extra arrays for the
calculation of the residual array will not be altered, and can be used in your
objective function in whatever form you send.  Usually, “array like” data will
work, but some care may be needed.  In the example above, if <code class="docutils literal notranslate"><span class="pre">x</span></code> was not a
numpy array but a list of numbers, this would give an error message like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">TypeError</span><span class="p">:</span> <span class="n">unsupported</span> <span class="n">operand</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="o">/</span><span class="p">:</span> <span class="s1">&#39;list&#39;</span> <span class="ow">and</span> <span class="s1">&#39;float&#39;</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">TypeError</span><span class="p">:</span> <span class="n">can</span><span class="s1">&#39;t multiply sequence by non-int of type &#39;</span><span class="nb">float</span><span class="s1">&#39;</span>
</pre></div>
</div>
<p>because a list of numbers is only sometimes “array like”.</p>
<p>Sending in a “more array-like” object like a pandas Series will avoid many
(though maybe not all!) such exceptions, but the resulting calculation returned
from the function would then also be a pandas Series.  Lmfit <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">minimize()</span></code></a> will
always coerce the return value from the objective function into a 1-D numpy
array with <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of “float64”.  This will usually “just work”, but there
may be exceptions.</p>
<p>When in doubt, or if running it trouble, converting data to float64 numpy
arrays before being used in a fit is recommended.  If using complex data or
functions, a <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of “complex128” will also always work, and will be
converted to “float64” with <code class="docutils literal notranslate"><span class="pre">ndaarray.view(&quot;float64&quot;)</span></code>.  Numpy arrays of other
<code class="docutils literal notranslate"><span class="pre">dtype</span></code> (say, “int16” or “float32”) should be used with caution.  In
particular, “float32” data should be avoided: Multiplying a “float32” array and
a Python float will result in a “float32” array for example.  As fitting
variables may have small changes made to them, the results may be at or below
“float32” precision, which will cause the fit to give up.  For integer data,
results are more sometimes promoted to “float64”, but many numpy ufuncs (say,
<code class="docutils literal notranslate"><span class="pre">numpy.exp()</span></code>) will promote only to “float32”, so care is still needed.</p>
<p>See also <a class="reference internal" href="model.html#model-data-coercion-section"><span class="std std-ref">Data Types for data  and independent data with Model</span></a> for discussion of data passed in for
curve-fitting.</p>
</section>
<section id="choosing-different-fitting-methods">
<span id="fit-methods-label"></span><h2>Choosing Different Fitting Methods<a class="headerlink" href="#choosing-different-fitting-methods" title="Link to this heading">¶</a></h2>
<p>By default, the <a class="reference external" href="https://en.wikipedia.org/wiki/Levenberg-Marquardt_algorithm">Levenberg-Marquardt</a> algorithm is
used for fitting. While often criticized, including the fact it finds a
<em>local</em> minimum, this approach has some distinct advantages. These include
being fast, and well-behaved for most curve-fitting needs, and making it
easy to estimate uncertainties for and correlations between pairs of fit
variables, as discussed in <a class="reference internal" href="#fit-results-label"><span class="std std-ref">MinimizerResult – the optimization result</span></a>.</p>
<p>Alternative algorithms can also be used by providing the <code class="docutils literal notranslate"><span class="pre">method</span></code>
keyword to the <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> function or <a class="reference internal" href="#lmfit.minimizer.Minimizer.minimize" title="lmfit.minimizer.Minimizer.minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.minimize()</span></code></a>
class as listed in the <a class="reference internal" href="#fit-methods-table"><span class="std std-ref">Table of Supported Fitting Methods</span></a>. If you have the <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> package installed, lmfit
will try to estimate the covariance matrix and determine parameter
uncertainties and correlations if <code class="docutils literal notranslate"><span class="pre">calc_covar</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> (default).</p>
<blockquote id="fit-methods-table">
<div><p>Table of Supported Fitting Methods:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Fitting Method</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">method</span></code> arg to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> or <a class="reference internal" href="#lmfit.minimizer.Minimizer.minimize" title="lmfit.minimizer.Minimizer.minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.minimize()</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Levenberg-Marquardt</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">leastsq</span></code> or <code class="docutils literal notranslate"><span class="pre">least_squares</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Nelder-Mead</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">nelder</span></code></p></td>
</tr>
<tr class="row-even"><td><p>L-BFGS-B</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lbfgsb</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Powell</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">powell</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Conjugate Gradient</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cg</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Newton-CG</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">newton</span></code></p></td>
</tr>
<tr class="row-even"><td><p>COBYLA</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cobyla</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>BFGS</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bfgsb</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Truncated Newton</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">tnc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Newton CG trust-region</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">trust-ncg</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Exact trust-region</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">trust-exact</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Newton GLTR trust-region</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">trust-krylov</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Constrained trust-region</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">trust-constr</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Dogleg</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">dogleg</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Sequential Linear
Squares Programming</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">slsqp</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Differential
Evolution</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">differential_evolution</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Brute force method</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">brute</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Basinhopping</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">basinhopping</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Adaptive Memory
Programming for Global
Optimization</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ampgo</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Simplicial Homology
Global Optimization</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">shgo</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Dual Annealing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">dual_annealing</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Maximum likelihood via
Monte-Carlo Markov Chain</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">emcee</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The objective function for the Levenberg-Marquardt method <strong>must</strong>
return an array, with more elements than variables. All other methods
can return either a scalar value or an array. The Monte-Carlo Markov
Chain or <code class="docutils literal notranslate"><span class="pre">emcee</span></code> method has two different operating methods when the
objective function returns a scalar value. See the documentation for <code class="docutils literal notranslate"><span class="pre">emcee</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Much of this documentation assumes that the Levenberg-Marquardt (<code class="docutils literal notranslate"><span class="pre">leastsq</span></code>)
method is used. Many of the fit statistics and estimates for uncertainties in
parameters discussed in <a class="reference internal" href="#fit-results-label"><span class="std std-ref">MinimizerResult – the optimization result</span></a> are done only unconditionally
for this (and the <code class="docutils literal notranslate"><span class="pre">least_squares</span></code>) method. Lmfit versions newer than 0.9.11
provide the capability to use <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> to estimate the covariance matrix
and calculate parameter uncertainties and correlations for other methods as
well.</p>
</div>
</section>
<section id="minimizerresult-the-optimization-result">
<span id="fit-results-label"></span><h2><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a> – the optimization result<a class="headerlink" href="#minimizerresult-the-optimization-result" title="Link to this heading">¶</a></h2>
<p>An optimization with <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> or <a class="reference internal" href="#lmfit.minimizer.Minimizer.minimize" title="lmfit.minimizer.Minimizer.minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.minimize()</span></code></a>
will return a <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a> object. This is an otherwise
plain container object (that is, with no methods of its own) that
simply holds the results of the minimization. These results will
include several pieces of informational data such as status and error
messages, fit statistics, and the updated parameters themselves.</p>
<p>Importantly, the parameters passed in to <a class="reference internal" href="#lmfit.minimizer.Minimizer.minimize" title="lmfit.minimizer.Minimizer.minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.minimize()</span></code></a>
will be not be changed. To find the best-fit values, uncertainties
and so on for each parameter, one must use the
<a class="reference internal" href="#lmfit.minimizer.MinimizerResult.params" title="lmfit.minimizer.MinimizerResult.params"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MinimizerResult.params</span></code></a> attribute. For example, to print the
fitted values, bounds and other parameter attributes in a
well-formatted text tables you can execute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">()</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">results</span></code> being a <code class="docutils literal notranslate"><span class="pre">MinimizerResult</span></code> object. Note that the method
<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters.pretty_print" title="lmfit.parameter.Parameters.pretty_print"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pretty_print()</span></code></a> accepts several arguments
for customizing the output (e.g., column width, numeric format, etcetera).</p>
<dl class="py class">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MinimizerResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult" title="Link to this definition">¶</a></dt>
<dd><p>The results of a minimization.</p>
<p>Minimization results include data such as status and error messages,
fit statistics, and the updated (i.e., best-fit) parameters themselves
in the <a class="reference internal" href="#lmfit.minimizer.MinimizerResult.params" title="lmfit.minimizer.MinimizerResult.params"><code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code></a> attribute.</p>
<p>The list of (possible) <cite>MinimizerResult</cite> attributes is given below:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.residual">
<span class="sig-name descname"><span class="pre">residual</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.residual" title="Link to this definition">¶</a></dt>
<dd><p>Residual array <span class="math notranslate nohighlight">\({\rm Resid_i}\)</span>. Return value of the objective
function when using the best-fit values of the parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)">numpy.ndarray</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.params">
<span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.params" title="Link to this definition">¶</a></dt>
<dd><p>The best-fit Parameters resulting from the fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters">Parameters</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.uvars">
<span class="sig-name descname"><span class="pre">uvars</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.uvars" title="Link to this definition">¶</a></dt>
<dd><p>Dictionary of uncertainties ufloats from Parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.var_names">
<span class="sig-name descname"><span class="pre">var_names</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.var_names" title="Link to this definition">¶</a></dt>
<dd><p>list of variable Parameter names used in optimization in the
same order as the values in <a class="reference internal" href="#lmfit.minimizer.MinimizerResult.init_vals" title="lmfit.minimizer.MinimizerResult.init_vals"><code class="xref py py-attr docutils literal notranslate"><span class="pre">init_vals</span></code></a> and <a class="reference internal" href="#lmfit.minimizer.MinimizerResult.covar" title="lmfit.minimizer.MinimizerResult.covar"><code class="xref py py-attr docutils literal notranslate"><span class="pre">covar</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.covar">
<span class="sig-name descname"><span class="pre">covar</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.covar" title="Link to this definition">¶</a></dt>
<dd><p>Covariance matrix from minimization, with rows and columns
corresponding to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult.var_names" title="lmfit.minimizer.MinimizerResult.var_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">var_names</span></code></a>.  If uncertainties cannot
be determined, this value will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)">numpy.ndarray</a> or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.init_vals">
<span class="sig-name descname"><span class="pre">init_vals</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.init_vals" title="Link to this definition">¶</a></dt>
<dd><p>List of initial values for variable parameters using
<a class="reference internal" href="#lmfit.minimizer.MinimizerResult.var_names" title="lmfit.minimizer.MinimizerResult.var_names"><code class="xref py py-attr docutils literal notranslate"><span class="pre">var_names</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.init_values">
<span class="sig-name descname"><span class="pre">init_values</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.init_values" title="Link to this definition">¶</a></dt>
<dd><p>Dictionary of initial values for variable parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.aborted">
<span class="sig-name descname"><span class="pre">aborted</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.aborted" title="Link to this definition">¶</a></dt>
<dd><p>Whether the fit was aborted.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.status">
<span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.status" title="Link to this definition">¶</a></dt>
<dd><p>Termination status of the optimizer. Its value depends on the
underlying solver. Refer to <cite>message</cite> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.success">
<span class="sig-name descname"><span class="pre">success</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.success" title="Link to this definition">¶</a></dt>
<dd><p>True if the fit succeeded, otherwise False. This is an optimistic
view of success, meaning that the method finished without error.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.errorbars">
<span class="sig-name descname"><span class="pre">errorbars</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.errorbars" title="Link to this definition">¶</a></dt>
<dd><p>whether uncertainties were estimated for variable Parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.message">
<span class="sig-name descname"><span class="pre">message</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.message" title="Link to this definition">¶</a></dt>
<dd><p>Message about fit success.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.ier">
<span class="sig-name descname"><span class="pre">ier</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.ier" title="Link to this definition">¶</a></dt>
<dd><p>Integer error value from <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.leastsq.html">scipy.optimize.leastsq</a> (<cite>‘leastsq’</cite>
method only).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.lmdif_message">
<span class="sig-name descname"><span class="pre">lmdif_message</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.lmdif_message" title="Link to this definition">¶</a></dt>
<dd><p>Message from <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.leastsq.html">scipy.optimize.leastsq</a> (<cite>‘leastsq’</cite> method only).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.call_kws">
<span class="sig-name descname"><span class="pre">call_kws</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.call_kws" title="Link to this definition">¶</a></dt>
<dd><p>Keyword arguments sent to underlying solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.flatchain">
<span class="sig-name descname"><span class="pre">flatchain</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.flatchain" title="Link to this definition">¶</a></dt>
<dd><p>A flatchain view of the sampling chain from the <cite>emcee</cite> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v2.2.3)">pandas.DataFrame</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.nfev">
<span class="sig-name descname"><span class="pre">nfev</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.nfev" title="Link to this definition">¶</a></dt>
<dd><p>Number of function evaluations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.nvarys">
<span class="sig-name descname"><span class="pre">nvarys</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.nvarys" title="Link to this definition">¶</a></dt>
<dd><p>Number of variables in fit: <span class="math notranslate nohighlight">\(N_{\rm varys}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.ndata">
<span class="sig-name descname"><span class="pre">ndata</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.ndata" title="Link to this definition">¶</a></dt>
<dd><p>Number of data points: <span class="math notranslate nohighlight">\(N\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.nfree">
<span class="sig-name descname"><span class="pre">nfree</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.nfree" title="Link to this definition">¶</a></dt>
<dd><p>Degrees of freedom in fit: <span class="math notranslate nohighlight">\(N - N_{\rm varys}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.chisqr">
<span class="sig-name descname"><span class="pre">chisqr</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.chisqr" title="Link to this definition">¶</a></dt>
<dd><p>Chi-square: <span class="math notranslate nohighlight">\(\chi^2 = \sum_i^N [{\rm Resid}_i]^2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.redchi">
<span class="sig-name descname"><span class="pre">redchi</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.redchi" title="Link to this definition">¶</a></dt>
<dd><p>Reduced chi-square:
<span class="math notranslate nohighlight">\(\chi^2_{\nu}= {\chi^2} / {(N - N_{\rm varys})}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.aic">
<span class="sig-name descname"><span class="pre">aic</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.aic" title="Link to this definition">¶</a></dt>
<dd><p>Akaike Information Criterion statistic:
<span class="math notranslate nohighlight">\(N \ln(\chi^2/N) + 2 N_{\rm varys}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.bic">
<span class="sig-name descname"><span class="pre">bic</span></span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.bic" title="Link to this definition">¶</a></dt>
<dd><p>Bayesian Information Criterion statistic:
<span class="math notranslate nohighlight">\(N \ln(\chi^2/N) + \ln(N) N_{\rm varys}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)">float</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.MinimizerResult.show_candidates">
<span class="sig-name descname"><span class="pre">show_candidates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.MinimizerResult.show_candidates" title="Link to this definition">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">pretty_print()</span></code> representation of candidates from the <cite>brute</cite>
fitting method.</p>
</dd></dl>

</dd></dl>

<section id="goodness-of-fit-statistics">
<h3>Goodness-of-Fit Statistics<a class="headerlink" href="#goodness-of-fit-statistics" title="Link to this heading">¶</a></h3>
<blockquote id="goodfit-table">
<div><p>Table of Fit Results: These values, including the standard Goodness-of-Fit statistics,
are all attributes of the <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a> object returned by
<a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> or <a class="reference internal" href="#lmfit.minimizer.Minimizer.minimize" title="lmfit.minimizer.Minimizer.minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.minimize()</span></code></a>.</p>
</div></blockquote>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Attribute Name</p></th>
<th class="head"><p>Description / Formula</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nfev</p></td>
<td><p>number of function evaluations</p></td>
</tr>
<tr class="row-odd"><td><p>nvarys</p></td>
<td><p>number of variables in fit <span class="math notranslate nohighlight">\(N_{\rm varys}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>ndata</p></td>
<td><p>number of data points: <span class="math notranslate nohighlight">\(N\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>nfree</p></td>
<td><p>degrees of freedom in fit: <span class="math notranslate nohighlight">\(N - N_{\rm varys}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>aborted</p></td>
<td><p>boolean of whether the fit has been aborted.</p></td>
</tr>
<tr class="row-odd"><td><p>success</p></td>
<td><p>boolean for a minimal test of whether the fit finished successfully</p></td>
</tr>
<tr class="row-even"><td><p>errorbars</p></td>
<td><p>boolean of whether error bars and unccertainty were estimated</p></td>
</tr>
<tr class="row-odd"><td><p>ier</p></td>
<td><p>integer flag describing message from <code class="docutils literal notranslate"><span class="pre">leastsq</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>message</p></td>
<td><p>simple message from <code class="docutils literal notranslate"><span class="pre">leastsq</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>method</p></td>
<td><p>name of fitting methods</p></td>
</tr>
<tr class="row-even"><td><p>residual</p></td>
<td><p>residual array, returned by the objective function: <span class="math notranslate nohighlight">\(\{\rm Resid_i\}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>chisqr</p></td>
<td><p>chi-square: <span class="math notranslate nohighlight">\(\chi^2 = \sum_i^N [{\rm Resid}_i]^2\)</span></p></td>
</tr>
<tr class="row-even"><td><p>redchi</p></td>
<td><p>reduced chi-square: <span class="math notranslate nohighlight">\(\chi^2_{\nu}= {\chi^2} / {(N - N_{\rm varys})}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>aic</p></td>
<td><p>Akaike Information Criterion statistic (see below)</p></td>
</tr>
<tr class="row-even"><td><p>bic</p></td>
<td><p>Bayesian Information Criterion statistic (see below)</p></td>
</tr>
<tr class="row-odd"><td><p>params</p></td>
<td><p>best-fit parameters after fit, with uncertainties is available</p></td>
</tr>
<tr class="row-even"><td><p>var_names</p></td>
<td><p>ordered list of variable parameter names used for init_vals and covar</p></td>
</tr>
<tr class="row-odd"><td><p>covar</p></td>
<td><p>covariance matrix (with rows/columns using var_names)</p></td>
</tr>
<tr class="row-even"><td><p>init_vals</p></td>
<td><p>list of initial values for variable parameters</p></td>
</tr>
<tr class="row-odd"><td><p>init_values</p></td>
<td><p>dictionary of initial values for variable Parameters.</p></td>
</tr>
<tr class="row-even"><td><p>uvars</p></td>
<td><p>dictionary of uncertainties uvalues for all Parameters.</p></td>
</tr>
<tr class="row-odd"><td><p>call_kws</p></td>
<td><p>dict of keyword arguments sent to underlying solver</p></td>
</tr>
</tbody>
</table>
<p>Note that the calculation of chi-square and reduced chi-square assume
that the returned residual function is scaled properly to the
uncertainties in the data. For these statistics to be meaningful, the
person writing the function to be minimized <strong>must</strong> scale them properly.</p>
<p>After a fit using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">leastsq()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">least_squares()</span></code> method has
completed successfully, standard errors for the fitted variables and
correlations between pairs of fitted variables are automatically calculated from
the covariance matrix. For other methods, the <code class="docutils literal notranslate"><span class="pre">calc_covar</span></code> parameter (default
is <code class="docutils literal notranslate"><span class="pre">True</span></code>) in the <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> class determines whether or not to use the
<code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> package to estimate the covariance matrix. The standard error
(estimated <span class="math notranslate nohighlight">\(1\sigma\)</span> error-bar) goes into the <code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code> attribute of
the Parameter. The correlations with all other variables will be put into the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">correl</span></code> attribute of the Parameter – a dictionary with keys for all
other Parameters and values of the corresponding correlation.</p>
<p>In some cases, it may not be possible to estimate the errors and
correlations. For example, if a variable actually has no practical effect
on the fit, it will likely cause the covariance matrix to be singular,
making standard errors impossible to estimate. Placing bounds on varied
Parameters makes it more likely that errors cannot be estimated, as being
near the maximum or minimum value makes the covariance matrix singular. In
these cases, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">errorbars</span></code> attribute of the fit result
(<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> object) will be <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</section>
<section id="akaike-and-bayesian-information-criteria">
<span id="information-criteria-label"></span><h3>Akaike and Bayesian Information Criteria<a class="headerlink" href="#akaike-and-bayesian-information-criteria" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a> includes the traditional chi-square and
reduced chi-square statistics:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
     \chi^2  &amp;=&amp;  \sum_i^N r_i^2 \\
     \chi^2_\nu &amp;=&amp; \chi^2 / (N-N_{\rm varys})
 \end{eqnarray*}</div><p>where <span class="math notranslate nohighlight">\(r\)</span> is the residual array returned by the objective function
(likely to be <code class="docutils literal notranslate"><span class="pre">(data-model)/uncertainty</span></code> for data modeling usages),
<span class="math notranslate nohighlight">\(N\)</span> is the number of data points (<code class="docutils literal notranslate"><span class="pre">ndata</span></code>), and <span class="math notranslate nohighlight">\(N_{\rm
varys}\)</span> is number of variable parameters.</p>
<p>Also included are the <a class="reference external" href="https://en.wikipedia.org/wiki/Akaike_information_criterion">Akaike Information Criterion</a>, and
<a class="reference external" href="https://en.wikipedia.org/wiki/Bayesian_information_criterion">Bayesian Information Criterion</a> statistics,
held in the <code class="docutils literal notranslate"><span class="pre">aic</span></code> and <code class="docutils literal notranslate"><span class="pre">bic</span></code> attributes, respectively. These give slightly
different measures of the relative quality for a fit, trying to balance
quality of fit with the number of variable parameters used in the fit.
These are calculated as:</p>
<div class="math notranslate nohighlight">
\begin{eqnarray*}
  {\rm aic} &amp;=&amp;  N \ln(\chi^2/N) + 2 N_{\rm varys} \\
  {\rm bic} &amp;=&amp;  N \ln(\chi^2/N) + \ln(N) N_{\rm varys} \\
 \end{eqnarray*}</div><p>When comparing fits with different numbers of varying parameters, one
typically selects the model with lowest reduced chi-square, Akaike
information criterion, and/or Bayesian information criterion. Generally,
the Bayesian information criterion is considered the most conservative of
these statistics.</p>
</section>
<section id="uncertainties-in-variable-parameters-and-their-correlations">
<h3>Uncertainties in Variable Parameters, and their Correlations<a class="headerlink" href="#uncertainties-in-variable-parameters-and-their-correlations" title="Link to this heading">¶</a></h3>
<p>As mentioned above, when a fit is complete the uncertainties for fitted
Parameters as well as the correlations between pairs of Parameters are usually
calculated. This happens automatically either when using the default
<code class="xref py py-meth docutils literal notranslate"><span class="pre">leastsq()</span></code> method, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">least_squares()</span></code> method, or for most other
fitting methods if the highly-recommended <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> package is
available. The estimated standard error (the <span class="math notranslate nohighlight">\(1\sigma\)</span> uncertainty) for
each variable Parameter will be contained in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code>, while the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">correl</span></code> attribute for each Parameter will contain a dictionary of the
correlation with each other variable Parameter.  These updated parameters with
uncertainty and correlation information will be placed in
<code class="docutils literal notranslate"><span class="pre">MinimizerResult.params</span></code>, so that you may access the best fit value, standard
error and correlation. For a successful fit for which uncertainties and
correlations can be calculated, the <code class="docutils literal notranslate"><span class="pre">MinimizerResult</span></code> will also have a
<code class="docutils literal notranslate"><span class="pre">uvars</span></code> attribute that is a dictionary with keynames for each Parameter
(includnig constraints) and values of <code class="docutils literal notranslate"><span class="pre">Ufloats</span></code> from the <a class="reference external" href="https://github.com/lebigot/uncertainties/">uncertainties</a>
package using the best fit values, the standard error and the correlation
between Parameters.</p>
<p>These estimates of the uncertainties are done by inverting the Hessian
matrix which represents the second derivative of fit quality for each
variable parameter. There are situations for which the uncertainties cannot
be estimated, which generally indicates that this matrix cannot be inverted
because one of the fit is not actually sensitive to one of the variables.
This can happen if a Parameter is stuck at an upper or lower bound, if the
variable is simply not used by the fit, or if the value for the variable is
such that it has no real influence on the fit.</p>
<p>In principle, the scale of the uncertainties in the Parameters is closely
tied to the goodness-of-fit statistics chi-square and reduced chi-square
(<code class="docutils literal notranslate"><span class="pre">chisqr</span></code> and <code class="docutils literal notranslate"><span class="pre">redchi</span></code>). The standard errors or <span class="math notranslate nohighlight">\(1 \sigma\)</span>
uncertainties are those that increase chi-square by 1. Since a “good fit”
should have <code class="docutils literal notranslate"><span class="pre">redchi</span></code> of around 1, this requires that the data
uncertainties (and to some extent the sampling of the N data points) is
correct. Unfortunately, it is often not the case that one has high-quality
estimates of the data uncertainties (getting the data is hard enough!).
Because of this common situation, the uncertainties reported and held in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code> are not those that increase chi-square by 1, but those that
increase chi-square by reduced chi-square. This is equivalent to rescaling
the uncertainty in the data such that reduced chi-square would be 1. To be
clear, this rescaling is done by default because if reduced chi-square is
far from 1, this rescaling often makes the reported uncertainties sensible,
and if reduced chi-square is near 1 it does little harm. If you have good
scaling of the data uncertainty and believe the scale of the residual
array is correct,  this automatic rescaling can be turned off using
<code class="docutils literal notranslate"><span class="pre">scale_covar=False</span></code>.</p>
<p>Note that the simple (and fast!) approach to estimating uncertainties and
correlations by inverting the second derivative matrix assumes that the
components of the residual array (if, indeed, an array is used) are
distributed around 0 with a normal (Gaussian distribution), and that a map
of probability distributions for pairs would be elliptical – the size of
the of ellipse gives the uncertainty itself and the eccentricity of the
ellipse gives the correlation. This simple approach to assessing
uncertainties ignores outliers, highly asymmetric uncertainties, or complex
correlations between Parameters. In fact, it is not too hard to come up
with problems where such effects are important. Our experience is that the
automated results are usually the right scale and quite reasonable as
initial estimates, but a more thorough exploration of the Parameter space
using the tools described in <a class="reference internal" href="#label-emcee"><span class="std std-ref">Minimizer.emcee() - calculating the posterior probability distribution of parameters</span></a> and
<a class="reference internal" href="confidence.html#label-confidence-advanced"><span class="std std-ref">An advanced example for evaluating confidence intervals</span></a> can give a more complete understanding of
the distributions and relations between Parameters.</p>
</section>
</section>
<section id="getting-and-printing-fit-reports">
<span id="fit-reports-label"></span><h2>Getting and Printing Fit Reports<a class="headerlink" href="#getting-and-printing-fit-reports" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="lmfit.printfuncs.fit_report">
<span class="sig-name descname"><span class="pre">fit_report</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelpars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_correl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_correl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_pars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correl_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'list'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.printfuncs.fit_report" title="Link to this definition">¶</a></dt>
<dd><p>Generate a report of the fitting results.</p>
<p>The report contains the best-fit values for the parameters and their
uncertainties and correlations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inpars</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a>) – Input Parameters from fit or MinimizerResult returned from a fit.</p></li>
<li><p><strong>modelpars</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Known Model Parameters.</p></li>
<li><p><strong>show_correl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to show list of sorted correlations (default is True).</p></li>
<li><p><strong>min_correl</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em>, </em><em>optional</em>) – Smallest correlation in absolute value to show (default is 0.1).</p></li>
<li><p><strong>sort_pars</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em> or </em><em>callable</em><em>, </em><em>optional</em>) – Whether to show parameter names sorted in alphanumerical order. If
False (default), then the parameters will be listed in the order
they were added to the Parameters dictionary. If callable, then
this (one argument) function is used to extract a comparison key
from each list element.</p></li>
<li><p><strong>correl_mode</strong> (<em>{'list'</em><em>, </em><em>table'} str</em><em>, </em><em>optional</em>) – Mode for how to show correlations. Can be either ‘list’ (default)
to show a sorted (if <code class="docutils literal notranslate"><span class="pre">sort_pars</span></code> is True) list of correlation
values, or ‘table’ to show a complete, formatted table of
correlations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Multi-line text of fit report.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a></p>
</dd>
</dl>
</dd></dl>

<p>An example using this to write out a fit report would be:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &lt;examples/doc_fitting_withreport.py&gt;</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">sin</span>

<span class="kn">from</span> <span class="nn">lmfit</span> <span class="kn">import</span> <span class="n">create_params</span><span class="p">,</span> <span class="n">fit_report</span><span class="p">,</span> <span class="n">minimize</span>

<span class="n">p_true</span> <span class="o">=</span> <span class="n">create_params</span><span class="p">(</span><span class="n">amp</span><span class="o">=</span><span class="mf">14.0</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mf">5.46</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">0.123</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.032</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model a decaying sine wave and subtract data.&quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">pars</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;amp&#39;</span><span class="p">]</span>
    <span class="n">per</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;period&#39;</span><span class="p">]</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span>
    <span class="n">decay</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="s1">&#39;decay&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">sign</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="n">per</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">decay</span><span class="o">*</span><span class="n">decay</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">model</span>
    <span class="k">return</span> <span class="n">model</span> <span class="o">-</span> <span class="n">data</span>


<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">250.</span><span class="p">,</span> <span class="mi">1001</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.7215</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">residual</span><span class="p">(</span><span class="n">p_true</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span>

<span class="n">fit_params</span> <span class="o">=</span> <span class="n">create_params</span><span class="p">(</span><span class="n">amp</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">fit_params</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="n">kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="n">fit_report</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
<span class="c1"># &lt;end examples/doc_fitting_withreport.py&gt;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>which would give as output:</p>
<div class="jupyter_cell docutils container">
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[Fit Statistics]]
    # fitting method   = leastsq
    # function evals   = 83
    # data points      = 1001
    # variables        = 4
    chi-square         = 498.811759
    reduced chi-square = 0.50031270
    Akaike info crit   = -689.222517
    Bayesian info crit = -669.587497
[[Variables]]
    amp:     13.9121959 +/- 0.14120321 (1.01%) (init = 13)
    period:  5.48507038 +/- 0.02666520 (0.49%) (init = 2)
    shift:   0.16203673 +/- 0.01405662 (8.67%) (init = 0)
    decay:   0.03264539 +/- 3.8015e-04 (1.16%) (init = 0.02)
[[Correlations]] (unreported correlations are &lt; 0.100)
    C(period, shift) = +0.7974
    C(amp, decay)    = +0.5816
    C(amp, shift)    = -0.2966
    C(amp, period)   = -0.2432
    C(shift, decay)  = -0.1819
    C(period, decay) = -0.1496
</pre></div>
</div>
</div>
</div>
<p>To be clear, you can get at all of these values from the fit result <code class="docutils literal notranslate"><span class="pre">out</span></code>
and <code class="docutils literal notranslate"><span class="pre">out.params</span></code>. For example, a crude printout of the best fit variables
and standard errors could be done as</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parameter    Value       Stderr&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s1">7s</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="si">:</span><span class="s1">11.5f</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">stderr</span><span class="si">:</span><span class="s1">11.5f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>-------------------------------
Parameter    Value       Stderr
amp        13.91220     0.14120
period      5.48507     0.02667
shift       0.16204     0.01406
decay       0.03265     0.00038
</pre></div>
</div>
</div>
</div>
</section>
<section id="using-a-iteration-callback-function">
<span id="fit-itercb-label"></span><h2>Using a Iteration Callback Function<a class="headerlink" href="#using-a-iteration-callback-function" title="Link to this heading">¶</a></h2>
<p>An iteration callback function is a function to be called at each
iteration, just after the objective function is called. The iteration
callback allows user-supplied code to be run at each iteration, and can
be used to abort a fit.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">iter_cb(params,</span> <span class="pre">iter,</span> <span class="pre">resid,</span> <span class="pre">*args,</span> <span class="pre">**kws):</span></span></dt>
<dd><p>User-supplied function to be run at each iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code></a>) – Parameters.</p></li>
<li><p><strong>iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Iteration number.</p></li>
<li><p><strong>resid</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><em>numpy.ndarray</em></a>) – Residual array.</p></li>
<li><p><strong>args</strong> – Positional arguments. Must match <code class="docutils literal notranslate"><span class="pre">args</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a></p></li>
<li><p><strong>kws</strong> – Keyword arguments. Must match <code class="docutils literal notranslate"><span class="pre">kws</span></code> argument to <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Iteration abort flag.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None for normal behavior, any value like <code class="docutils literal notranslate"><span class="pre">True</span></code> to abort the fit.</p>
</dd>
</dl>
</dd></dl>

<p>Normally, the iteration callback would have no return value or return
<code class="docutils literal notranslate"><span class="pre">None</span></code>. To abort a fit, have this function return a value that is
<code class="docutils literal notranslate"><span class="pre">True</span></code> (including any non-zero integer). The fit will also abort if any
exception is raised in the iteration callback. When a fit is aborted this
way, the parameters will have the values from the last iteration. The fit
statistics are not likely to be meaningful, and uncertainties will not be computed.</p>
</section>
<section id="using-the-minimizer-class">
<span id="fit-minimizer-label"></span><h2>Using the <a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> class<a class="headerlink" href="#using-the-minimizer-class" title="Link to this heading">¶</a></h2>
<p>For full control of the fitting process, you will want to create a
<a class="reference internal" href="#lmfit.minimizer.Minimizer" title="lmfit.minimizer.Minimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Minimizer</span></code></a> object.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Minimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">userfcn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fcn_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fcn_kws</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_cb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'raise'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_fcn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_covar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer" title="Link to this definition">¶</a></dt>
<dd><p>A general minimizer for curve fitting and optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>userfcn</strong> (<em>callable</em>) – <p>Objective function that returns the residual (difference
between model and data) to be minimized in a least-squares
sense. This function must have the signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">userfcn</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">fcn_args</span><span class="p">,</span> <span class="o">**</span><span class="n">fcn_kws</span><span class="p">)</span>
</pre></div>
</div>
</p></li>
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a>) – Contains the Parameters for the model.</p></li>
<li><p><strong>fcn_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a><em>, </em><em>optional</em>) – Positional arguments to pass to <cite>userfcn</cite>.</p></li>
<li><p><strong>fcn_kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Keyword arguments to pass to <cite>userfcn</cite>.</p></li>
<li><p><strong>iter_cb</strong> (<em>callable</em><em>, </em><em>optional</em>) – <p>Function to be called at each fit iteration. This function
should have the signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iter_cb</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="o">*</span><span class="n">fcn_args</span><span class="p">,</span> <span class="o">**</span><span class="n">fcn_kws</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>params</cite> will have the current parameter values, <cite>iter</cite>
the iteration number, <cite>resid</cite> the current residual array, and
<cite>*fcn_args</cite> and <cite>**fcn_kws</cite> are passed to the objective
function.</p>
</p></li>
<li><p><strong>scale_covar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to automatically scale the covariance matrix (default
is True).</p></li>
<li><p><strong>nan_policy</strong> (<em>{'raise'</em><em>, </em><em>'propagate'</em><em>, </em><em>'omit}</em><em>, </em><em>optional</em>) – <p>Specifies action if <cite>userfcn</cite> (or a Jacobian) returns NaN
values. One of:</p>
<ul>
<li><p><cite>’raise’</cite> : a <cite>ValueError</cite> is raised (default)</p></li>
<li><p><cite>’propagate’</cite> : the values returned from <cite>userfcn</cite> are un-altered</p></li>
<li><p><cite>’omit’</cite> : non-finite values are filtered</p></li>
</ul>
</p></li>
<li><p><strong>reduce_fcn</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em> or </em><em>callable</em><em>, </em><em>optional</em>) – <p>Function to convert a residual array to a scalar value for the
scalar minimizers. Optional values are (where <cite>r</cite> is the
residual array):</p>
<ul>
<li><p>None : sum-of-squares of residual (default)</p>
<blockquote>
<div><p>= (r*r).sum()</p>
</div></blockquote>
</li>
<li><p><cite>’negentropy’</cite> : neg entropy, using normal distribution</p>
<blockquote>
<div><p>= rho*log(rho).sum()`, where rho = exp(-r*r/2)/(sqrt(2*pi))</p>
</div></blockquote>
</li>
<li><p><cite>’neglogcauchy’</cite> : neg log likelihood, using Cauchy distribution</p>
<blockquote>
<div><p>= -log(1/(pi*(1+r*r))).sum()</p>
</div></blockquote>
</li>
<li><p>callable : must take one argument (<cite>r</cite>) and return a float.</p></li>
</ul>
</p></li>
<li><p><strong>calc_covar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to calculate the covariance matrix (default is True)
for solvers other than <code class="docutils literal notranslate"><span class="pre">'leastsq'</span></code> and <code class="docutils literal notranslate"><span class="pre">'least_squares'</span></code>.
Requires the <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> package to be installed.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations (default is None). The
default value depends on the fitting method.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Options to pass to the minimizer being used.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The objective function should return the value to be minimized.
For the Levenberg-Marquardt algorithm from <a class="reference internal" href="#lmfit.minimizer.Minimizer.leastsq" title="lmfit.minimizer.Minimizer.leastsq"><code class="xref py py-meth docutils literal notranslate"><span class="pre">leastsq()</span></code></a> or
<a class="reference internal" href="#lmfit.minimizer.Minimizer.least_squares" title="lmfit.minimizer.Minimizer.least_squares"><code class="xref py py-meth docutils literal notranslate"><span class="pre">least_squares()</span></code></a>, this returned value must be an array, with
a length greater than or equal to the number of fitting variables
in the model. For the other methods, the return value can either be
a scalar or an array. If an array is returned, the sum-of-squares
of the array will be sent to the underlying fitting method,
effectively doing a least-squares optimization of the return
values. If the objective function returns non-finite values then a
<cite>ValueError</cite> will be raised because the underlying solvers cannot
deal with them.</p>
<p>A common use for the <cite>fcn_args</cite> and <cite>fcn_kws</cite> would be to pass in
other data needed to calculate the residual, including such things
as the data array, dependent variable, uncertainties in the data,
and other data structures for the model calculation.</p>
</dd></dl>

<p>The Minimizer object has a few public methods:</p>
<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.minimize">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'leastsq'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.minimize" title="Link to this definition">¶</a></dt>
<dd><p>Perform the minimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – <p>Name of the fitting method to use. Valid values are:</p>
<ul>
<li><p><cite>’leastsq’</cite>: Levenberg-Marquardt (default)</p></li>
<li><p><cite>’least_squares’</cite>: Least-Squares minimization, using Trust
Region Reflective method</p></li>
<li><p><cite>’differential_evolution’</cite>: differential evolution</p></li>
<li><p><cite>’brute’</cite>: brute force method</p></li>
<li><p><cite>’basinhopping’</cite>: basinhopping</p></li>
<li><p><cite>’ampgo’</cite>: Adaptive Memory Programming for Global
Optimization</p></li>
<li><p><cite>’nelder’</cite>: Nelder-Mead</p></li>
<li><p><cite>’lbfgsb’</cite>: L-BFGS-B</p></li>
<li><p><cite>’powell’</cite>: Powell</p></li>
<li><p><cite>’cg’</cite>: Conjugate-Gradient</p></li>
<li><p><cite>’newton’</cite>: Newton-CG</p></li>
<li><p><cite>’cobyla’</cite>: Cobyla</p></li>
<li><p><cite>’bfgs’</cite>: BFGS</p></li>
<li><p><cite>’tnc’</cite>: Truncated Newton</p></li>
<li><p><cite>’trust-ncg’</cite>: Newton-CG trust-region</p></li>
<li><p><cite>’trust-exact’</cite>: nearly exact trust-region</p></li>
<li><p><cite>’trust-krylov’</cite>: Newton GLTR trust-region</p></li>
<li><p><cite>’trust-constr’</cite>: trust-region for constrained optimization</p></li>
<li><p><cite>’dogleg’</cite>: Dog-leg trust-region</p></li>
<li><p><cite>’slsqp’</cite>: Sequential Linear Squares Programming</p></li>
<li><p><cite>’emcee’</cite>: Maximum likelihood via Monte-Carlo Markov Chain</p></li>
<li><p><cite>’shgo’</cite>: Simplicial Homology Global Optimization</p></li>
<li><p><cite>’dual_annealing’</cite>: Dual Annealing optimization</p></li>
</ul>
<p>In most cases, these methods wrap and use the method with the
same name from <cite>scipy.optimize</cite>, or use
<cite>scipy.optimize.minimize</cite> with the same <cite>method</cite> argument.
Thus <cite>‘leastsq’</cite> will use <cite>scipy.optimize.leastsq</cite>, while
<cite>‘powell’</cite> will use <cite>scipy.optimize.minimizer(…,
method=’powell’)</cite>.</p>
<p>For more details on the fitting methods please refer to the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.html">SciPy documentation</a>.</p>
</p></li>
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Parameters of the model to use as starting values.</p></li>
<li><p><strong>**kws</strong> (<em>optional</em>) – Additional arguments are passed to the underlying minimization
method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the optimized parameters and several
goodness-of-fit statistics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.0: </span>Return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.leastsq">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">leastsq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.leastsq" title="Link to this definition">¶</a></dt>
<dd><p>Use Levenberg-Marquardt minimization to perform a fit.</p>
<p>It assumes that the input Parameters have been initialized, and a
function to minimize has been properly set up. When possible, this
calculates the estimated uncertainties and variable correlations
from the covariance matrix.</p>
<p>This method calls <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.leastsq.html">scipy.optimize.leastsq</a> and, by default,
numerical derivatives are used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Parameters to use as starting point.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations. Defaults to
<code class="docutils literal notranslate"><span class="pre">2000*(nvars+1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">nvars</span></code> is the number of variable
parameters.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Minimizer options to pass to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.leastsq.html">scipy.optimize.leastsq</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the optimized parameters and several
goodness-of-fit statistics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.0: </span>Return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.least_squares">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">least_squares</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.least_squares" title="Link to this definition">¶</a></dt>
<dd><p>Least-squares minimization using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html">scipy.optimize.least_squares</a>.</p>
<p>This method wraps <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html">scipy.optimize.least_squares</a>, which has
built-in support for bounds and robust loss functions. By default
it uses the Trust Region Reflective algorithm with a linear loss
function (i.e., the standard least-squares problem).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Parameters to use as starting point.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations. Defaults to
<code class="docutils literal notranslate"><span class="pre">2000*(nvars+1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">nvars</span></code> is the number of variable
parameters.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Minimizer options to pass to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html">scipy.optimize.least_squares</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the optimized parameters and several
goodness-of-fit statistics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.0: </span>Return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.scalar_minimize">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">scalar_minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Nelder-Mead'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.scalar_minimize" title="Link to this definition">¶</a></dt>
<dd><p>Scalar minimization using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a>.</p>
<p>Perform fit with any of the scalar minimization algorithms
supported by <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a>. Default argument
values are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#lmfit.minimizer.Minimizer.scalar_minimize" title="lmfit.minimizer.Minimizer.scalar_minimize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scalar_minimize()</span></code></a>
arg</p></th>
<th class="head"><p>Default Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>method</cite></p></td>
<td><p>‘Nelder-Mead’</p></td>
<td><p>fitting method</p></td>
</tr>
<tr class="row-odd"><td><p><cite>tol</cite></p></td>
<td><p>1.e-7</p></td>
<td><p>fitting and parameter
tolerance</p></td>
</tr>
<tr class="row-even"><td><p><cite>hess</cite></p></td>
<td><p>None</p></td>
<td><p>Hessian of objective
function</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – <p>Name of the fitting method to use. One of:</p>
<ul>
<li><p><cite>’Nelder-Mead’</cite> (default)</p></li>
<li><p><cite>’L-BFGS-B’</cite></p></li>
<li><p><cite>’Powell’</cite></p></li>
<li><p><cite>’CG’</cite></p></li>
<li><p><cite>’Newton-CG’</cite></p></li>
<li><p><cite>’COBYLA’</cite></p></li>
<li><p><cite>’BFGS’</cite></p></li>
<li><p><cite>’TNC’</cite></p></li>
<li><p><cite>’trust-ncg’</cite></p></li>
<li><p><cite>’trust-exact’</cite></p></li>
<li><p><cite>’trust-krylov’</cite></p></li>
<li><p><cite>’trust-constr’</cite></p></li>
<li><p><cite>’dogleg’</cite></p></li>
<li><p><cite>’SLSQP’</cite></p></li>
<li><p><cite>’differential_evolution’</cite></p></li>
</ul>
</p></li>
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Parameters to use as starting point.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations. Defaults to
<code class="docutils literal notranslate"><span class="pre">2000*(nvars+1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">nvars</span></code> is the number of variable
parameters.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Minimizer options pass to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the optimized parameters and several
goodness-of-fit statistics.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.0: </span>Return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>.</p>
</div>
<p class="rubric">Notes</p>
<p>If the objective function returns a NumPy array instead of the
expected scalar, the sum-of-squares of the array will be used.</p>
<p>Note that bounds and constraints can be set on Parameters for any
of these methods, so are not supported separately for those
designed to use bounds. However, if you use the
<code class="docutils literal notranslate"><span class="pre">differential_evolution</span></code> method you must specify finite
<code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> for each varying Parameter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.prepare_fit">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">prepare_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.prepare_fit" title="Link to this definition">¶</a></dt>
<dd><p>Prepare parameters for fitting.</p>
<p>Prepares and initializes model and Parameters for subsequent
fitting. This routine prepares the conversion of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Parameters</span></code> into fit variables, organizes parameter bounds,
and parses, “compiles” and checks constrain expressions. The method
also creates and returns a new instance of a
<a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a> object that contains the copy of the
Parameters that will actually be varied in the fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Contains the Parameters for the model; if None, then the
Parameters used to initialize the Minimizer object are used.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method is called directly by the fitting methods, and it is
generally not necessary to call this function explicitly.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.9.0: </span>Return value changed to <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.brute">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">brute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.brute" title="Link to this definition">¶</a></dt>
<dd><p>Use the <cite>brute</cite> method to find the global minimum of a function.</p>
<p>The following parameters are passed to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html">scipy.optimize.brute</a>
and cannot be changed:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><a class="reference internal" href="#lmfit.minimizer.Minimizer.brute" title="lmfit.minimizer.Minimizer.brute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">brute()</span></code></a> arg</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>full_output</cite></p></td>
<td><p>1</p></td>
<td><p>Return the evaluation grid and the
objective function’s values on it.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>finish</cite></p></td>
<td><p>None</p></td>
<td><p>No “polishing” function is to be
used after the grid search.</p></td>
</tr>
<tr class="row-even"><td><p><cite>disp</cite></p></td>
<td><p>False</p></td>
<td><p>Do not print convergence messages
(when finish is not None).</p></td>
</tr>
</tbody>
</table>
<p>It assumes that the input Parameters have been initialized, and a
function to minimize has been properly set up.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Contains the Parameters for the model. If None, then the
Parameters used to initialize the Minimizer object are used.</p></li>
<li><p><strong>Ns</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Number of grid points along the axes, if not otherwise
specified (see Notes).</p></li>
<li><p><strong>keep</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Number of best candidates from the brute force method that are
stored in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">candidates</span></code> attribute. If <cite>‘all’</cite>, then
all grid points from <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html">scipy.optimize.brute</a> are stored as
candidates.</p></li>
<li><p><strong>workers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>map-like callable</em><em>, </em><em>optional</em>) – For parallel evaluation of the grid (see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html">scipy.optimize.brute</a>
for more details).</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations (default is None). Defaults
to <code class="docutils literal notranslate"><span class="pre">200000*(nvarys+1)</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the parameters from the brute force method.
The return values (<code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">fval</span></code>, <code class="docutils literal notranslate"><span class="pre">grid</span></code>, <code class="docutils literal notranslate"><span class="pre">Jout</span></code>) from
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html">scipy.optimize.brute</a> are stored as <code class="docutils literal notranslate"><span class="pre">brute_&lt;parname&gt;</span></code>
attributes. The <cite>MinimizerResult</cite> also contains the
:attr:<code class="docutils literal notranslate"><span class="pre">candidates</span></code> attribute and <code class="xref py py-meth docutils literal notranslate"><span class="pre">show_candidates()</span></code>
method. The <code class="xref py py-attr docutils literal notranslate"><span class="pre">candidates</span></code> attribute contains the
parameters and chisqr from the brute force method as a
namedtuple, <code class="docutils literal notranslate"><span class="pre">('Candidate',</span> <span class="pre">['params',</span> <span class="pre">'score'])</span></code> sorted on
the (lowest) chisqr value. To access the values for a
particular candidate one can use <code class="docutils literal notranslate"><span class="pre">result.candidate[#].params</span></code>
or <code class="docutils literal notranslate"><span class="pre">result.candidate[#].score</span></code>, where a lower # represents a
better candidate. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">show_candidates()</span></code> method uses the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">pretty_print()</span></code> method to show a specific candidate-# or
all candidates when no number is specified.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.9.6.</span></p>
</div>
<p class="rubric">Notes</p>
<p>The <a class="reference internal" href="#lmfit.minimizer.Minimizer.brute" title="lmfit.minimizer.Minimizer.brute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">brute()</span></code></a> method evaluates the function at each point of a
multidimensional grid of points. The grid points are generated from
the parameter ranges using <cite>Ns</cite> and (optional) <cite>brute_step</cite>.
The implementation in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brute.html">scipy.optimize.brute</a> requires finite
bounds and the <code class="docutils literal notranslate"><span class="pre">range</span></code> is specified as a two-tuple <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code>
or slice-object <code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max,</span> <span class="pre">brute_step)</span></code>. A slice-object is used
directly, whereas a two-tuple is converted to a slice object that
interpolates <cite>Ns</cite> points from <code class="docutils literal notranslate"><span class="pre">min</span></code> to <code class="docutils literal notranslate"><span class="pre">max</span></code>, inclusive.</p>
<p>In addition, the <a class="reference internal" href="#lmfit.minimizer.Minimizer.brute" title="lmfit.minimizer.Minimizer.brute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">brute()</span></code></a> method in lmfit, handles three other
scenarios given below with their respective slice-object:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>lower bound (<code class="xref py py-attr docutils literal notranslate"><span class="pre">min</span></code>) and <code class="xref py py-attr docutils literal notranslate"><span class="pre">brute_step</span></code> are specified:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">(min,</span> <span class="pre">min</span> <span class="pre">+</span> <span class="pre">Ns</span> <span class="pre">*</span> <span class="pre">brute_step,</span> <span class="pre">brute_step)</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>upper bound (<code class="xref py py-attr docutils literal notranslate"><span class="pre">max</span></code>) and <code class="xref py py-attr docutils literal notranslate"><span class="pre">brute_step</span></code> are specified:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">(max</span> <span class="pre">-</span> <span class="pre">Ns</span> <span class="pre">*</span> <span class="pre">brute_step,</span> <span class="pre">max,</span> <span class="pre">brute_step)</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>numerical value (<code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code>) and <code class="xref py py-attr docutils literal notranslate"><span class="pre">brute_step</span></code> are specified:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">range</span> <span class="pre">=</span> <span class="pre">(value</span> <span class="pre">-</span> <span class="pre">(Ns//2)</span> <span class="pre">*</span> <span class="pre">brute_step`,</span> <span class="pre">value</span> <span class="pre">+</span>
<span class="pre">(Ns//2)</span> <span class="pre">*</span> <span class="pre">brute_step,</span> <span class="pre">brute_step)</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<p>For more information, check the examples in <code class="docutils literal notranslate"><span class="pre">examples/lmfit_brute_example.ipynb</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.basinhopping">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">basinhopping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.basinhopping" title="Link to this definition">¶</a></dt>
<dd><p>Use the <cite>basinhopping</cite> algorithm to find the global minimum.</p>
<p>This method calls <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.basinhopping.html">scipy.optimize.basinhopping</a> using the
default arguments. The default minimizer is <code class="docutils literal notranslate"><span class="pre">BFGS</span></code>, but since
lmfit supports parameter bounds for all minimizers, the user can
choose any of the solvers present in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">scipy.optimize.minimize</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Contains the Parameters for the model. If None, then the
Parameters used to initialize the Minimizer object are used.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations (default is None). Defaults
to <code class="docutils literal notranslate"><span class="pre">200000*(nvarys+1)</span></code>.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Minimizer options to pass to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.basinhopping.html">scipy.optimize.basinhopping</a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the optimization results from the
basinhopping algorithm.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.9.10.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.ampgo">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">ampgo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.ampgo" title="Link to this definition">¶</a></dt>
<dd><p>Find the global minimum of a multivariate function using AMPGO.</p>
<p>AMPGO stands for ‘Adaptive Memory Programming for Global
Optimization’ and is an efficient algorithm to find the global
minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Contains the Parameters for the model. If None, then the
Parameters used to initialize the Minimizer object are used.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Maximum number of total function evaluations. If None
(default), the optimization will stop after <cite>totaliter</cite> number
of iterations (see below)..</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – <p>Minimizer options to pass to the ampgo algorithm, the options
are listed below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>local: str, optional
    Name of the local minimization method. Valid options
    are:
    - `&#39;L-BFGS-B&#39;` (default)
    - `&#39;Nelder-Mead&#39;`
    - `&#39;Powell&#39;`
    - `&#39;TNC&#39;`
    - `&#39;SLSQP&#39;`
local_opts: dict, optional
    Options to pass to the local minimizer (default is
    None).
maxfunevals: int, optional
    Maximum number of function evaluations. If None
    (default), the optimization will stop after
    `totaliter` number of iterations (deprecated: use
    `max_nfev` instead).
totaliter: int, optional
    Maximum number of global iterations (default is 20).
maxiter: int, optional
    Maximum number of `Tabu Tunneling` iterations during
    each global iteration (default is 5).
glbtol: float, optional
    Tolerance whether or not to accept a solution after a
    tunneling phase (default is 1e-5).
eps1: float, optional
    Constant used to define an aspiration value for the
    objective function during the Tunneling phase (default
    is 0.02).
eps2: float, optional
    Perturbation factor used to move away from the latest
    local minimum at the start of a Tunneling phase
    (default is 0.1).
tabulistsize: int, optional
    Size of the (circular) tabu search list (default is 5).
tabustrategy: {&#39;farthest&#39;, &#39;oldest&#39;}, optional
    Strategy to use when the size of the tabu list exceeds
    `tabulistsize`. It can be `&#39;oldest&#39;` to drop the oldest
    point from the tabu list or `&#39;farthest&#39;` (defauilt) to
    drop the element farthest from the last local minimum
    found.
disp: bool, optional
    Set to True to print convergence messages (default is
    False).
</pre></div>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the parameters from the ampgo method, with
fit parameters, statistics and such. The return values
(<code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">fval</span></code>, <code class="docutils literal notranslate"><span class="pre">eval</span></code>, <code class="docutils literal notranslate"><span class="pre">msg</span></code>, <code class="docutils literal notranslate"><span class="pre">tunnel</span></code>) are stored
as <code class="docutils literal notranslate"><span class="pre">ampgo_&lt;parname&gt;</span></code> attributes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.9.10.</span></p>
</div>
<p class="rubric">Notes</p>
<p>The Python implementation was written by Andrea Gavana in 2014
(<a class="reference external" href="http://infinity77.net/global_optimization/index.html">http://infinity77.net/global_optimization/index.html</a>).</p>
<p>The details of the AMPGO algorithm are described in the paper
“Adaptive Memory Programming for Constrained Global Optimization”
located here:</p>
<p><a class="reference external" href="http://leeds-faculty.colorado.edu/glover/fred%20pubs/416%20-%20AMP%20(TS)%20for%20Constrained%20Global%20Opt%20w%20Lasdon%20et%20al%20.pdf">http://leeds-faculty.colorado.edu/glover/fred%20pubs/416%20-%20AMP%20(TS)%20for%20Constrained%20Global%20Opt%20w%20Lasdon%20et%20al%20.pdf</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.shgo">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">shgo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.shgo" title="Link to this definition">¶</a></dt>
<dd><p>Use the <cite>SHGO</cite> algorithm to find the global minimum.</p>
<p>SHGO stands for “simplicial homology global optimization” and
calls <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.shgo.html">scipy.optimize.shgo</a> using its default arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Contains the Parameters for the model. If None, then the
Parameters used to initialize the Minimizer object are used.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations. Defaults to
<code class="docutils literal notranslate"><span class="pre">200000*(nvars+1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">nvars</span></code> is the number of variable
parameters.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Minimizer options to pass to the SHGO algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the parameters from the SHGO method.
The return values specific to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.shgo.html">scipy.optimize.shgo</a>
(<code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">xl</span></code>, <code class="docutils literal notranslate"><span class="pre">fun</span></code>, <code class="docutils literal notranslate"><span class="pre">funl</span></code>, <code class="docutils literal notranslate"><span class="pre">nfev</span></code>, <code class="docutils literal notranslate"><span class="pre">nit</span></code>,
<code class="docutils literal notranslate"><span class="pre">nlfev</span></code>, <code class="docutils literal notranslate"><span class="pre">nlhev</span></code>, and <code class="docutils literal notranslate"><span class="pre">nljev</span></code>) are stored as
<code class="docutils literal notranslate"><span class="pre">shgo_&lt;parname&gt;</span></code> attributes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.9.14.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.dual_annealing">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">dual_annealing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kws</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.dual_annealing" title="Link to this definition">¶</a></dt>
<dd><p>Use the <cite>dual_annealing</cite> algorithm to find the global minimum.</p>
<p>This method calls <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.dual_annealing.html">scipy.optimize.dual_annealing</a> using its
default arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Contains the Parameters for the model. If None, then the
Parameters used to initialize the Minimizer object are used.</p></li>
<li><p><strong>max_nfev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Maximum number of function evaluations. Defaults to
<code class="docutils literal notranslate"><span class="pre">200000*(nvars+1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">nvars</span></code> is the number of variables.</p></li>
<li><p><strong>**kws</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Minimizer options to pass to the dual_annealing algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Object containing the parameters from the dual_annealing
method. The return values specific to
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.dual_annealing.html">scipy.optimize.dual_annealing</a> (<code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">fun</span></code>, <code class="docutils literal notranslate"><span class="pre">nfev</span></code>,
<code class="docutils literal notranslate"><span class="pre">nhev</span></code>, <code class="docutils literal notranslate"><span class="pre">njev</span></code>, and <code class="docutils literal notranslate"><span class="pre">nit</span></code>) are stored as
<code class="docutils literal notranslate"><span class="pre">da_&lt;parname&gt;</span></code> attributes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.9.14.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lmfit.minimizer.Minimizer.emcee">
<span class="sig-prename descclassname"><span class="pre">Minimizer.</span></span><span class="sig-name descname"><span class="pre">emcee</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntemps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">float_behavior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'posterior'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_mcmc_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lmfit.minimizer.Minimizer.emcee" title="Link to this definition">¶</a></dt>
<dd><p>Bayesian sampling of the posterior distribution.</p>
<p>The method uses the <code class="docutils literal notranslate"><span class="pre">emcee</span></code> Markov Chain Monte Carlo package and
assumes that the prior is Uniform. You need to have <code class="docutils literal notranslate"><span class="pre">emcee</span></code>
version 3 or newer installed to use this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> (<a class="reference internal" href="parameters.html#lmfit.parameter.Parameters" title="lmfit.parameter.Parameters"><em>Parameters</em></a><em>, </em><em>optional</em>) – Parameters to use as starting point. If this is not specified
then the Parameters used to initialize the Minimizer object
are used.</p></li>
<li><p><strong>steps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – How many samples you would like to draw from the posterior
distribution for each of the walkers?</p></li>
<li><p><strong>nwalkers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Should be set so <span class="math notranslate nohighlight">\(nwalkers &gt;&gt; nvarys\)</span>, where <code class="docutils literal notranslate"><span class="pre">nvarys</span></code>
are the number of parameters being varied during the fit.
‘Walkers are the members of the ensemble. They are almost like
separate Metropolis-Hastings chains but, of course, the proposal
distribution for a given walker depends on the positions of all
the other walkers in the ensemble.’ - from the <cite>emcee</cite> webpage.</p></li>
<li><p><strong>burn</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Discard this many samples from the start of the sampling regime.</p></li>
<li><p><strong>thin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – Only accept 1 in every <cite>thin</cite> samples.</p></li>
<li><p><strong>ntemps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>deprecated</em>) – ntemps has no effect.</p></li>
<li><p><strong>pos</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.2)"><em>numpy.ndarray</em></a><em>, </em><em>optional</em>) – Specify the initial positions for the sampler, an ndarray of
shape <code class="docutils literal notranslate"><span class="pre">(nwalkers,</span> <span class="pre">nvarys)</span></code>. You can also initialise using a
previous chain of the same <cite>nwalkers</cite> and <code class="docutils literal notranslate"><span class="pre">nvarys</span></code>. Note that
<code class="docutils literal notranslate"><span class="pre">nvarys</span></code> may be one larger than you expect it to be if your
<code class="docutils literal notranslate"><span class="pre">userfcn</span></code> returns an array and <code class="docutils literal notranslate"><span class="pre">is_weighted=False</span></code>.</p></li>
<li><p><strong>reuse_sampler</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Set to True if you have already run <cite>emcee</cite> with the
<cite>Minimizer</cite> instance and want to continue to draw from its
<code class="docutils literal notranslate"><span class="pre">sampler</span></code> (and so retain the chain history). If False, a
new sampler is created. The keywords <cite>nwalkers</cite>, <cite>pos</cite>, and
<cite>params</cite> will be ignored when this is set, as they will be set
by the existing sampler.
<strong>Important</strong>: the Parameters used to create the sampler must
not change in-between calls to <cite>emcee</cite>. Alteration of Parameters
would include changed <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">vary</span></code> and <code class="docutils literal notranslate"><span class="pre">expr</span></code>
attributes. This may happen, for example, if you use an altered
Parameters object and call the <cite>minimize</cite> method in-between
calls to <cite>emcee</cite>.</p></li>
<li><p><strong>workers</strong> (<em>Pool-like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em>, </em><em>optional</em>) – For parallelization of sampling. It can be any Pool-like object
with a map method that follows the same calling sequence as the
built-in <cite>map</cite> function. If int is given as the argument, then
a multiprocessing-based pool is spawned internally with the
corresponding number of parallel processes. ‘mpi4py’-based
parallelization and ‘joblib’-based parallelization pools can
also be used here. <strong>Note</strong>: because of multiprocessing
overhead it may only be worth parallelising if the objective
function is expensive to calculate, or if there are a large
number of objective evaluations per step
(<code class="docutils literal notranslate"><span class="pre">nwalkers</span> <span class="pre">*</span> <span class="pre">nvarys</span></code>).</p></li>
<li><p><strong>float_behavior</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><em>optional</em>) – Meaning of float (scalar) output of objective function. Use
<cite>‘posterior’</cite> if it returns a log-posterior probability or
<cite>‘chi2’</cite> if it returns <span class="math notranslate nohighlight">\(\chi^2\)</span>. See Notes for further
details.</p></li>
<li><p><strong>is_weighted</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Has your objective function been weighted by measurement
uncertainties? If <code class="docutils literal notranslate"><span class="pre">is_weighted=True</span></code> then your objective
function is assumed to return residuals that have been divided
by the true measurement uncertainty <code class="docutils literal notranslate"><span class="pre">(data</span> <span class="pre">-</span> <span class="pre">model)</span> <span class="pre">/</span> <span class="pre">sigma</span></code>.
If <code class="docutils literal notranslate"><span class="pre">is_weighted=False</span></code> then the objective function is
assumed to return unweighted residuals, <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">-</span> <span class="pre">model</span></code>. In
this case <cite>emcee</cite> will employ a positive measurement
uncertainty during the sampling. This measurement uncertainty
will be present in the output params and output chain with the
name <code class="docutils literal notranslate"><span class="pre">__lnsigma</span></code>. A side effect of this is that you cannot
use this parameter name yourself.
<strong>Important</strong>: this parameter only has any effect if your
objective function returns an array. If your objective function
returns a float, then this parameter is ignored. See Notes for
more details.</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v2.2)"><em>numpy.random.RandomState</em></a><em>, </em><em>optional</em>) – If <cite>seed</cite> is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, a new <cite>numpy.random.RandomState</cite>
instance is used, seeded with <cite>seed</cite>.
If <cite>seed</cite> is already a <cite>numpy.random.RandomState</cite> instance,
then that <cite>numpy.random.RandomState</cite> instance is used. Specify
<cite>seed</cite> for repeatable minimizations.</p></li>
<li><p><strong>progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a><em>, </em><em>optional</em>) – Print a progress bar to the console while running.</p></li>
<li><p><strong>run_mcmc_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><em>dict</em></a><em>, </em><em>optional</em>) – Additional (optional) keyword arguments that are passed to
<code class="docutils literal notranslate"><span class="pre">emcee.EnsembleSampler.run_mcmc</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>MinimizerResult object containing updated params, statistics,
etc. The updated params represent the median of the samples,
while the uncertainties are half the difference of the 15.87
and 84.13 percentiles. The <cite>MinimizerResult</cite> contains a few
additional attributes: <cite>chain</cite> contain the samples and has
shape <code class="docutils literal notranslate"><span class="pre">((steps</span> <span class="pre">-</span> <span class="pre">burn)</span> <span class="pre">//</span> <span class="pre">thin,</span> <span class="pre">nwalkers,</span> <span class="pre">nvarys)</span></code>.
<cite>flatchain</cite> is a <cite>pandas.DataFrame</cite> of the flattened chain,
that can be accessed with <cite>result.flatchain[parname]</cite>.
<cite>lnprob</cite> contains the log probability for each sample in
<cite>chain</cite>. The sample with the highest probability corresponds
to the maximum likelihood estimate. <cite>acor</cite> is an array
containing the auto-correlation time for each parameter if the
auto-correlation time can be computed from the chain. Finally,
<cite>acceptance_fraction</cite> (an array of the fraction of steps
accepted for each walker).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult">MinimizerResult</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method samples the posterior distribution of the parameters
using Markov Chain Monte Carlo. It calculates the log-posterior
probability of the model parameters, <cite>F</cite>, given the data, <cite>D</cite>,
<span class="math notranslate nohighlight">\(\ln p(F_{true} | D)\)</span>. This ‘posterior probability’ is
given by:</p>
<div class="math notranslate nohighlight">
\[\ln p(F_{true} | D) \propto \ln p(D | F_{true}) + \ln p(F_{true})\]</div>
<p>where <span class="math notranslate nohighlight">\(\ln p(D | F_{true})\)</span> is the ‘log-likelihood’ and
<span class="math notranslate nohighlight">\(\ln p(F_{true})\)</span> is the ‘log-prior’. The default log-prior
encodes prior information known about the model that the log-prior
probability is <code class="docutils literal notranslate"><span class="pre">-numpy.inf</span></code> (impossible) if any of the parameters
is outside its limits, and is zero if all the parameters are inside
their bounds (uniform prior). The log-likelihood function is <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:</p>
<div class="math notranslate nohighlight">
\[\ln p(D|F_{true}) = -\frac{1}{2}\sum_n \left[\frac{(g_n(F_{true}) - D_n)^2}{s_n^2}+\ln (2\pi s_n^2)\right]\]</div>
<p>The first term represents the residual (<span class="math notranslate nohighlight">\(g\)</span> being the
generative model, <span class="math notranslate nohighlight">\(D_n\)</span> the data and <span class="math notranslate nohighlight">\(s_n\)</span> the
measurement uncertainty). This gives <span class="math notranslate nohighlight">\(\chi^2\)</span> when summed
over all data points. The objective function may also return the
log-posterior probability, <span class="math notranslate nohighlight">\(\ln p(F_{true} | D)\)</span>. Since the
default log-prior term is zero, the objective function can also
just return the log-likelihood, unless you wish to create a
non-uniform prior.</p>
<p>If the objective function returns a float value, this is assumed
by default to be the log-posterior probability, (<cite>float_behavior</cite>
default is ‘posterior’). If your objective function returns
<span class="math notranslate nohighlight">\(\chi^2\)</span>, then you should use <code class="docutils literal notranslate"><span class="pre">float_behavior='chi2'</span></code>
instead.</p>
<p>By default objective functions may return an ndarray of (possibly
weighted) residuals. In this case, use <cite>is_weighted</cite> to select
whether these are correctly weighted by measurement uncertainty.
Note that this ignores the second term above, so that to calculate
a correct log-posterior probability value your objective function
should return a float value. With <code class="docutils literal notranslate"><span class="pre">is_weighted=False</span></code> the data
uncertainty, <cite>s_n</cite>, will be treated as a nuisance parameter to be
marginalized out. This uses strictly positive uncertainty
(homoscedasticity) for each data point,
<span class="math notranslate nohighlight">\(s_n = \exp(\rm{\_\_lnsigma})\)</span>. <code class="docutils literal notranslate"><span class="pre">__lnsigma</span></code> will be
present in <cite>MinimizerResult.params</cite>, as well as <cite>Minimizer.chain</cite>
and <code class="docutils literal notranslate"><span class="pre">nvarys</span></code> will be increased by one.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://emcee.readthedocs.io">https://emcee.readthedocs.io</a></p>
</aside>
</aside>
</dd></dl>

</section>
<section id="minimizer-emcee-calculating-the-posterior-probability-distribution-of-parameters">
<span id="label-emcee"></span><h2><a class="reference internal" href="#lmfit.minimizer.Minimizer.emcee" title="lmfit.minimizer.Minimizer.emcee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.emcee()</span></code></a> - calculating the posterior probability distribution of parameters<a class="headerlink" href="#minimizer-emcee-calculating-the-posterior-probability-distribution-of-parameters" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="#lmfit.minimizer.Minimizer.emcee" title="lmfit.minimizer.Minimizer.emcee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.emcee()</span></code></a> can be used to obtain the posterior probability
distribution of parameters, given a set of experimental data. Note that this
method does <em>not</em> actually perform a fit at all. Instead, it explores
parameter space to determine the probability distributions for the parameters,
but without an explicit goal of attempting to refine the solution. It should
not be used for fitting, but it is a useful method to to more thoroughly
explore the parameter space around the solution after a fit has been done and
thereby get an improved understanding of the probability distribution for the
parameters. It may be able to refine your estimate of the most likely values
for a set of parameters, but it will not iteratively find a good solution to
the minimization problem. To use this method effectively, you should first
use another minimization method and then use this method to explore the
parameter space around those best-fit values.</p>
<p>To illustrate this, we’ll use an example problem of fitting data to function
of a double exponential decay, including a modest amount of Gaussian noise to
the data. Note that this example is the same problem used in
<a class="reference internal" href="confidence.html#label-confidence-advanced"><span class="std std-ref">An advanced example for evaluating confidence intervals</span></a> for evaluating confidence intervals in the
parameters, which is a similar goal to the one here.</p>
<div class="jupyter_cell docutils container">
<div class="cell_output docutils container">
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">lmfit</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>Create a Parameter set for the initial guesses:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">Parameters</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_many</span><span class="p">((</span><span class="s1">&#39;a1&#39;</span><span class="p">,</span> <span class="mf">4.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a2&#39;</span><span class="p">,</span> <span class="mf">4.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;t1&#39;</span><span class="p">,</span> <span class="mf">3.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;t2&#39;</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">residual</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;a1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;a2&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>Solving with <a class="reference internal" href="#lmfit.minimizer.minimize" title="lmfit.minimizer.minimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimize()</span></code></a> gives the Maximum Likelihood solution. Note
that we use the robust Nelder-Mead method here. The default Levenberg-Marquardt
method seems to have difficulty with exponential decays, though it can refine
the solution if starting near the solution:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mi</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nelder&#39;</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span><span class="p">)</span>
<span class="n">lmfit</span><span class="o">.</span><span class="n">printfuncs</span><span class="o">.</span><span class="n">report_fit</span><span class="p">(</span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">min_correl</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[Variables]]
    a1:  2.98623689 +/- 0.15010518 (5.03%) (init = 4)
    a2: -4.33525597 +/- 0.11765816 (2.71%) (init = 4)
    t1:  1.30993186 +/- 0.13449649 (10.27%) (init = 3)
    t2:  11.8240752 +/- 0.47172578 (3.99%) (init = 3)
[[Correlations]] (unreported correlations are &lt; 0.500)
    C(a2, t2) = +0.9876
    C(a2, t1) = -0.9278
    C(t1, t2) = -0.8852
    C(a1, t1) = -0.6093
</pre></div>
</div>
</div>
</div>
<p>and plotting the fit using the Maximum Likelihood solution gives the graph below:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">residual</span><span class="p">(</span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;best fit&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/fitting_12_0.svg" src="_images/fitting_12_0.svg" /></div>
</div>
<p>Note that the fit here (for which the <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> package is installed)
does estimate and report uncertainties in the parameters and correlations for
the parameters, and reports the correlation of parameters <code class="docutils literal notranslate"><span class="pre">a2</span></code> and <code class="docutils literal notranslate"><span class="pre">t2</span></code> to
be very high. As we’ll see, these estimates are pretty good, but when faced
with such high correlation, it can be helpful to get the full probability
distribution for the parameters. MCMC methods are very good for this.</p>
<p>Furthermore, we wish to deal with the data uncertainty. This is called
marginalisation of a nuisance parameter. <code class="docutils literal notranslate"><span class="pre">emcee</span></code> requires a function that
returns the log-posterior probability. The log-posterior probability is a sum
of the log-prior probability and log-likelihood functions. The log-prior
probability is assumed to be zero if all the parameters are within their
bounds and <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code> if any of the parameters are outside their bounds.</p>
<p>If the objective function returns an array of unweighted residuals (i.e.,
<code class="docutils literal notranslate"><span class="pre">data-model</span></code>) as is the case here, you can use <code class="docutils literal notranslate"><span class="pre">is_weighted=False</span></code> as an
argument for <code class="docutils literal notranslate"><span class="pre">emcee</span></code>. In that case, <code class="docutils literal notranslate"><span class="pre">emcee</span></code> will automatically add/use the
<code class="docutils literal notranslate"><span class="pre">__lnsigma</span></code> parameter to estimate the true uncertainty in the data. To
place boundaries on this parameter one can do:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;__lnsigma&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.001</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>Now we have to set up the minimizer and do the sampling (again, just to be
clear, this is <em>not</em> doing a fit):</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">residual</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;emcee&#39;</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                     <span class="n">params</span><span class="o">=</span><span class="n">mi</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">is_weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>As mentioned in the Notes for <a class="reference internal" href="#lmfit.minimizer.Minimizer.emcee" title="lmfit.minimizer.Minimizer.emcee"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Minimizer.emcee()</span></code></a>, the <code class="docutils literal notranslate"><span class="pre">is_weighted</span></code>
argument will be ignored if your objective function returns a float instead of
an array. For the documentation we set <code class="docutils literal notranslate"><span class="pre">progress=False</span></code>; the default is to
print a progress bar to the Terminal if the <code class="docutils literal notranslate"><span class="pre">tqdm</span></code> package is installed.</p>
<p>The success of the method (i.e., whether or not the sampling went well) can be
assessed by checking the integrated autocorrelation time and/or the acceptance
fraction of the walkers. For this specific example the autocorrelation time
could not be estimated because the “chain is too short”. Instead, we plot the
acceptance fraction per walker and its mean value suggests that the sampling
worked as intended (as a rule of thumb the value should be between 0.2 and
0.5).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">acceptance_fraction</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;walker&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;acceptance fraction&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/fitting_15_0.svg" src="_images/fitting_15_0.svg" /></div>
</div>
<p>With the results from <code class="docutils literal notranslate"><span class="pre">emcee</span></code>, we can visualize the posterior distributions
for the parameters using the <code class="docutils literal notranslate"><span class="pre">corner</span></code> package:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">corner</span>

<span class="n">emcee_plot</span> <span class="o">=</span> <span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">flatchain</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span>
                           <span class="n">truths</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/fitting_16_0.svg" src="_images/fitting_16_0.svg" /></div>
</div>
<p>The values reported in the <a class="reference internal" href="#lmfit.minimizer.MinimizerResult" title="lmfit.minimizer.MinimizerResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinimizerResult</span></code></a> are the medians of the
probability distributions and a 1 <span class="math notranslate nohighlight">\(\sigma\)</span> quantile, estimated as half
the difference between the 15.8 and 84.2 percentiles. Printing these values:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;median of posterior probability distribution&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------&#39;</span><span class="p">)</span>
<span class="n">lmfit</span><span class="o">.</span><span class="n">report_fit</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>median of posterior probability distribution
--------------------------------------------
[[Variables]]
    a1:         2.98945718 +/- 0.14033921 (4.69%) (init = 2.986237)
    a2:        -4.34687243 +/- 0.12131092 (2.79%) (init = -4.335256)
    t1:         1.32883916 +/- 0.13766047 (10.36%) (init = 1.309932)
    t2:         11.7836194 +/- 0.47719763 (4.05%) (init = 11.82408)
    __lnsigma: -2.32559226 +/- 0.04542650 (1.95%) (init = -2.302585)
[[Correlations]] (unreported correlations are &lt; 0.100)
    C(a2, t2) = +0.9811
    C(a2, t1) = -0.9377
    C(t1, t2) = -0.8943
    C(a1, t1) = -0.5076
    C(a1, a2) = +0.2140
    C(a1, t2) = +0.1777
</pre></div>
</div>
</div>
</div>
<p>You can see that this recovered the right uncertainty level on the data. Note
that these values agree pretty well with the results, uncertainties and
correlations found by the fit and using <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> to estimate the
covariance matrix. That is, even though the parameters <code class="docutils literal notranslate"><span class="pre">a2</span></code>, <code class="docutils literal notranslate"><span class="pre">t1</span></code>, and
<code class="docutils literal notranslate"><span class="pre">t2</span></code> are all highly correlated and do not display perfectly Gaussian
probability distributions, the probability distributions found by explicitly
sampling the parameter space are not so far from elliptical as to make the
simple (and much faster) estimates from inverting the covariance matrix
completely invalid.</p>
<p>As mentioned above, the result from <code class="docutils literal notranslate"><span class="pre">emcee</span></code> reports the median values, which
are not necessarily the same as the Maximum Likelihood Estimate. To obtain
the values for the Maximum Likelihood Estimation (MLE) we find the location in
the chain with the highest probability:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">highest_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">lnprob</span><span class="p">)</span>
<span class="n">hp_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">highest_prob</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">lnprob</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">mle_soln</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">chain</span><span class="p">[</span><span class="n">hp_loc</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">p</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">mle_soln</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>


<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Maximum Likelihood Estimation from emcee       &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parameter  MLE Value   Median Value   Uncertainty&#39;</span><span class="p">)</span>
<span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;  </span><span class="si">{:5s}</span><span class="s1">  </span><span class="si">{:11.5f}</span><span class="s1"> </span><span class="si">{:11.5f}</span><span class="s1">   </span><span class="si">{:11.5f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
              <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>
Maximum Likelihood Estimation from emcee       
-------------------------------------------------
Parameter  MLE Value   Median Value   Uncertainty
  a1         2.93839     2.98946       0.14034
  a2        -4.35274    -4.34687       0.12131
  t1         1.34310     1.32884       0.13766
  t2        11.78782    11.78362       0.47720
</pre></div>
</div>
</div>
</div>
<p>Here the difference between MLE and median value are seen to be below 0.5%,
and well within the estimated 1-<span class="math notranslate nohighlight">\(\sigma\)</span> uncertainty.</p>
<p>Finally, we can use the samples from <code class="docutils literal notranslate"><span class="pre">emcee</span></code> to work out the 1- and
2-<span class="math notranslate nohighlight">\(\sigma\)</span> error estimates.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Error estimates from emcee:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;------------------------------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parameter  -2sigma  -1sigma   median  +1sigma  +2sigma&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">flatchain</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                              <span class="p">[</span><span class="mf">2.275</span><span class="p">,</span> <span class="mf">15.865</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">84.135</span><span class="p">,</span> <span class="mf">97.275</span><span class="p">])</span>
    <span class="n">median</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">err_m2</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">median</span>
    <span class="n">err_m1</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">median</span>
    <span class="n">err_p1</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">median</span>
    <span class="n">err_p2</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">median</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;  </span><span class="si">{:5s}</span><span class="s1">   </span><span class="si">{:8.4f}</span><span class="s1"> </span><span class="si">{:8.4f}</span><span class="s1"> </span><span class="si">{:8.4f}</span><span class="s1"> </span><span class="si">{:8.4f}</span><span class="s1"> </span><span class="si">{:8.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fmt</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">err_m2</span><span class="p">,</span> <span class="n">err_m1</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">err_p1</span><span class="p">,</span> <span class="n">err_p2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>
Error estimates from emcee:
------------------------------------------------------
Parameter  -2sigma  -1sigma   median  +1sigma  +2sigma
  a1       -0.2656  -0.1362   2.9895   0.1445   0.3141
  a2       -0.3209  -0.1309  -4.3469   0.1118   0.1985
  t1       -0.2377  -0.1305   1.3288   0.1448   0.3278
  t2       -1.0677  -0.4807  11.7836   0.4739   0.8990
</pre></div>
</div>
</div>
</div>
<p>And we see that the initial estimates for the 1-<span class="math notranslate nohighlight">\(\sigma\)</span> standard error
using <code class="docutils literal notranslate"><span class="pre">numdifftools</span></code> was not too bad. We’ll return to this example
problem in <a class="reference internal" href="confidence.html#label-confidence-advanced"><span class="std std-ref">An advanced example for evaluating confidence intervals</span></a> and use a different method to
calculate the 1- and 2-<span class="math notranslate nohighlight">\(\sigma\)</span> error bars.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="model.html" title="Modeling Data and Curve Fitting"
             >next</a> |</li>
        <li class="right" >
          <a href="parameters.html" title="Parameter and Parameters"
             >previous</a> |</li>
    <li>[ <a href="intro.html">intro</a> |</li>
    <li><a href="parameters.html">parameters</a> |</li>
    <li><a href="#">minimize</a> |</li>
    <li><a href="model.html">model</a> |</li>
    <li><a href="builtin_models.html">built-in models</a> |</li>
    <li><a href="confidence.html">confidence intervals</a> |</li>
    <li><a href="bounds.html">bounds</a> |</li>
    <li><a href="constraints.html">constraints</a> ]</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, Matthew Newville, Till Stensitzki, Renee Otten, and others.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>